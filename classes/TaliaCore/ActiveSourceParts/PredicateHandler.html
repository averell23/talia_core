<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: TaliaCore::ActiveSourceParts::PredicateHandler</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">TaliaCore::ActiveSourceParts::PredicateHandler</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../../files/lib/talia_core/active_source_parts/predicate_handler_rb.html">
                lib/talia_core/active_source_parts/predicate_handler.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
Methods for <a href="../ActiveSource.html">ActiveSource</a> objects for
accessing and handling predicates, which are the properties connected to
the source. When accessing a predicate/property of an <a
href="../ActiveSource.html">ActiveSource</a>, the system will return a <a
href="../SemanticCollectionWrapper.html">SemanticCollectionWrapper</a>.
</p>
<p>
Once a predicate is loaded, the <a
href="../ActiveSource.html">ActiveSource</a> will cache the <a
href="../SemanticCollectionWrapper.html">SemanticCollectionWrapper</a>
internally, and will re-use it on subsequent accesses.
</p>
<p>
If the relations are prefetched (usually by providing the
:prefetch_relations option to the find Method, see the <a
href="Finders.html">Finders</a> module), all wrappers for the source are
loaded at once; the actual prefetching is done by the
prefetch_relations_for method, which can also be used directly on a
collection of sources.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000079">each_cached_wrapper</a>&nbsp;&nbsp;
      <a href="#M000077">get_objects_on</a>&nbsp;&nbsp;
      <a href="#M000076">get_wrapper_on</a>&nbsp;&nbsp;
      <a href="#M000075">has_type?</a>&nbsp;&nbsp;
      <a href="#M000081">inject_predicate</a>&nbsp;&nbsp;
      <a href="#M000080">reset!</a>&nbsp;&nbsp;
      <a href="#M000078">save_wrappers</a>&nbsp;&nbsp;
      <a href="#M000074">types</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">

    <div id="class-list">
      <h3 class="section-bar">Classes and Modules</h3>

      Module <a href="PredicateHandler/ClassMethods.html" class="link">TaliaCore::ActiveSourceParts::PredicateHandler::ClassMethods</a><br />

    </div>




      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000079" class="method-detail">
        <a name="M000079"></a>

        <div class="method-heading">
          <a href="#M000079" class="method-signature">
          <span class="method-name">each_cached_wrapper</span><span class="method-args">() {|wrap| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Loops through the wrapper cache and passes each of the
SemanticCollectionWrappers in the cache to the block given to this method
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000079-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000079-source">
<pre>
     <span class="ruby-comment cmt"># File lib/talia_core/active_source_parts/predicate_handler.rb, line 127</span>
127:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">each_cached_wrapper</span>
128:         <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">unless</span>(<span class="ruby-ivar">@type_cache</span>)
129:         <span class="ruby-ivar">@type_cache</span>.<span class="ruby-identifier">each_value</span> {  <span class="ruby-operator">|</span><span class="ruby-identifier">wrap</span><span class="ruby-operator">|</span> <span class="ruby-keyword kw">yield</span>(<span class="ruby-identifier">wrap</span>) }
130:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000077" class="method-detail">
        <a name="M000077"></a>

        <div class="method-heading">
          <a href="#M000077" class="method-signature">
          <span class="method-name">get_objects_on</span><span class="method-args">(predicate)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the values for the given predicate. This will work like <a
href="PredicateHandler.html#M000076">get_wrapper_on</a> <em>except</em> if
the predicate is declared as a :singular_property with
ActiveSouce.property_options (or singular_property, or multi_property). In
that case, it will return only a single value. However, if the predicate is
declare singular and there already is more than one value, it will return
the wrapper (and fail an assit). In general, a property that was defined
singular and contains more than one value indicates a problem with the
application.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000077-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000077-source">
<pre>
     <span class="ruby-comment cmt"># File lib/talia_core/active_source_parts/predicate_handler.rb, line 99</span>
 99:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">get_objects_on</span>(<span class="ruby-identifier">predicate</span>)
100:         <span class="ruby-identifier">singular</span> = <span class="ruby-identifier">property_options_for</span>(<span class="ruby-identifier">predicate</span>)[<span class="ruby-identifier">:singular_property</span>].<span class="ruby-identifier">true?</span>
101:         <span class="ruby-identifier">wrapper</span> = <span class="ruby-identifier">get_wrapper_on</span>(<span class="ruby-identifier">predicate</span>) 
102: 
103:         <span class="ruby-keyword kw">if</span>(<span class="ruby-identifier">singular</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">wrapper</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">1</span>) 
104:           <span class="ruby-identifier">wrapper</span>.<span class="ruby-identifier">first</span>
105:         <span class="ruby-keyword kw">else</span>
106:           <span class="ruby-identifier">assit</span>(<span class="ruby-operator">!</span><span class="ruby-identifier">singular</span>, <span class="ruby-value str">'Was expecting a single value (property is defined as singular). Got more than one.'</span>)
107:           <span class="ruby-identifier">wrapper</span>
108:         <span class="ruby-keyword kw">end</span>
109:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000076" class="method-detail">
        <a name="M000076"></a>

        <div class="method-heading">
          <a href="#M000076" class="method-signature">
          <span class="method-name">get_wrapper_on</span><span class="method-args">(predicate)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the <a
href="../SemanticCollectionWrapper.html">SemanticCollectionWrapper</a> for
the given predicate. The collection wrapper will be cached internally, so
that subsequent calls will receive the same collection wrapper again.
</p>
<p>
This also means that any modifications to the wrapper are preserved in the
cache - if a wrapper is modified in memory, and accessed again _on the same
source_, a subsequent access will return the modified wrapper.
</p>
<p>
Modified wrappers are saved when the <a
href="../ActiveSource.html">ActiveSource</a> itself is saved (through <a
href="PredicateHandler.html#M000078">save_wrappers</a>, which is
automatically called)
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000076-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000076-source">
<pre>
    <span class="ruby-comment cmt"># File lib/talia_core/active_source_parts/predicate_handler.rb, line 75</span>
75:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">get_wrapper_on</span>(<span class="ruby-identifier">predicate</span>)
76:         <span class="ruby-ivar">@type_cache</span> <span class="ruby-operator">||=</span> {}
77:         <span class="ruby-identifier">active_wrapper</span> = <span class="ruby-ivar">@type_cache</span>[<span class="ruby-identifier">predicate</span>.<span class="ruby-identifier">to_s</span>]
78: 
79:         <span class="ruby-keyword kw">if</span>(<span class="ruby-identifier">active_wrapper</span>.<span class="ruby-identifier">nil?</span>)
80:           <span class="ruby-identifier">active_wrapper</span> = <span class="ruby-constant">SemanticCollectionWrapper</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-identifier">predicate</span>)
81:           
82:           <span class="ruby-comment cmt"># If this is a prefetched source we have everything, so we can </span>
83:           <span class="ruby-comment cmt"># initialize the wrapper without loading anything</span>
84:           <span class="ruby-identifier">active_wrapper</span>.<span class="ruby-identifier">init_as_empty!</span> <span class="ruby-keyword kw">if</span>(<span class="ruby-ivar">@prefetched</span>)
85:           
86:           <span class="ruby-ivar">@type_cache</span>[<span class="ruby-identifier">predicate</span>.<span class="ruby-identifier">to_s</span>] = <span class="ruby-identifier">active_wrapper</span>
87:         <span class="ruby-keyword kw">end</span>
88:         
89:         <span class="ruby-identifier">active_wrapper</span>
90:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000075" class="method-detail">
        <a name="M000075"></a>

        <div class="method-heading">
          <a href="#M000075" class="method-signature">
          <span class="method-name">has_type?</span><span class="method-args">(type)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Checks if the source has the given RDF type
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000075-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000075-source">
<pre>
    <span class="ruby-comment cmt"># File lib/talia_core/active_source_parts/predicate_handler.rb, line 61</span>
61:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">has_type?</span>(<span class="ruby-identifier">type</span>)
62:         (<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">types</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">type</span>))
63:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000081" class="method-detail">
        <a name="M000081"></a>

        <div class="method-heading">
          <a href="#M000081" class="method-signature">
          <span class="method-name">inject_predicate</span><span class="method-args">(relation)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Injects a &#8216;fat relation&#8217; into the cache/wrappter. A
&quot;fat&quot; relation is a <a
href="../SemanticRelation.html">SemanticRelation</a> which contains
additional fields (e.g. the subject uri, all object information, etc.) -
See also the <a
href="../SemanticCollectionWrapper.html">SemanticCollectionWrapper</a>
documentation.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000081-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000081-source">
<pre>
     <span class="ruby-comment cmt"># File lib/talia_core/active_source_parts/predicate_handler.rb, line 142</span>
142:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">inject_predicate</span>(<span class="ruby-identifier">relation</span>)
143:         <span class="ruby-identifier">wrapper</span> = <span class="ruby-identifier">get_wrapper_on</span>(<span class="ruby-identifier">relation</span>.<span class="ruby-identifier">predicate_uri</span>)
144:         <span class="ruby-identifier">wrapper</span>.<span class="ruby-identifier">insert_item</span>(<span class="ruby-identifier">relation</span>)
145:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000080" class="method-detail">
        <a name="M000080"></a>

        <div class="method-heading">
          <a href="#M000080" class="method-signature">
          <span class="method-name">reset!</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Resets the internal cache of wrappers/properties. Any unsaved changes on
the wrappers are lost, and get_object_on will have to reload all data when
it is called again
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000080-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000080-source">
<pre>
     <span class="ruby-comment cmt"># File lib/talia_core/active_source_parts/predicate_handler.rb, line 135</span>
135:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">reset!</span>
136:         <span class="ruby-ivar">@type_cache</span> = <span class="ruby-keyword kw">nil</span>
137:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000078" class="method-detail">
        <a name="M000078"></a>

        <div class="method-heading">
          <a href="#M000078" class="method-signature">
          <span class="method-name">save_wrappers</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Goes through the existing SemanticCollectionWrappers in the cache, and
saves any modifications that may exist.
</p>
<p>
This is automatically called when the source is saved.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000078-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000078-source">
<pre>
     <span class="ruby-comment cmt"># File lib/talia_core/active_source_parts/predicate_handler.rb, line 115</span>
115:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">save_wrappers</span>
116:         <span class="ruby-identifier">each_cached_wrapper</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">wrap</span><span class="ruby-operator">|</span>
117:           <span class="ruby-comment cmt"># Load unloaded if we're not rdf_autosaving. Quick hack since otherwise</span>
118:           <span class="ruby-comment cmt"># since the blanking of unloaded properties could cause problems with</span>
119:           <span class="ruby-comment cmt"># the rdf writing otherwise</span>
120:           <span class="ruby-identifier">wrap</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">:load!</span>) <span class="ruby-keyword kw">unless</span>(<span class="ruby-identifier">wrap</span>.<span class="ruby-identifier">loaded?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">autosave_rdf?</span>)
121:           <span class="ruby-identifier">wrap</span>.<span class="ruby-identifier">save_items!</span>
122:         <span class="ruby-keyword kw">end</span>
123:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000074" class="method-detail">
        <a name="M000074"></a>

        <div class="method-heading">
          <a href="#M000074" class="method-signature">
          <span class="method-name">types</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Gets the RDF <a href="PredicateHandler.html#M000074">types</a> for the
source. This is equivalent to accessing the rdf:type predicate.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000074-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000074-source">
<pre>
    <span class="ruby-comment cmt"># File lib/talia_core/active_source_parts/predicate_handler.rb, line 56</span>
56:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">types</span>
57:         <span class="ruby-identifier">get_objects_on</span>(<span class="ruby-constant">N</span><span class="ruby-operator">::</span><span class="ruby-constant">RDF</span>.<span class="ruby-identifier">type</span>.<span class="ruby-identifier">to_s</span>)
58:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>